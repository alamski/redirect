// Error handling function with improved user feedback
function showAlert(message, type = 'info', solution = null) {
  let alertHtml = `<div class="alert alert-${type}">${message}`;
  
  if (solution) {
    alertHtml += `<p class="alert-solution">${solution}</p>`;
  }
  
  alertHtml += '</div>';
  alertContainer.innerHTML = alertHtml;
  
  // Auto-hide success alerts after 5 seconds
  if (type === 'success') {
    setTimeout(() => {
      const alert = alertContainer.querySelector('.alert');
      if (alert) alert.remove();
    }, 5000);
  }
}

// Process files with improved error handling and retry logic
async function processFiles() {
  if (oldUrls.length === 0 || newUrls.length === 0) {
    showAlert(
      'Please upload both old and new URL files', 
      'error',
      'You need to upload two CSV files: one with old URLs and one with new URLs.'
    );
    return;
  }

  isProcessing = true;
  updateProcessButton();
  showAlert('');
  resultsContainer.style.display = 'none';
  progressContainer.style.display = 'block';
  updateProgress('Processing URLs...', 0);

  try {
    // Step 1: Process old URLs
    updateProgress('Processing old URLs...', 10);
    
    // Step 2: Process new URLs
    updateProgress('Processing new URLs...', 30);
    
    // Step 3: Find matches
    updateProgress('Finding best matches...', 50);
    
    // Get batch size and delay from settings
    const batchSizeValue = parseInt(batchSize.value) || 5;
    const batchDelayValue = parseInt(batchDelay.value) || 1000;
    
    // Validate settings
    if (batchSizeValue < 1 || batchSizeValue > 20) {
      throw new Error('Batch size must be between 1 and 20');
    }
    
    if (batchDelayValue < 500 || batchDelayValue > 5000) {
      throw new Error('Batch delay must be between 500ms and 5000ms');
    }
    
    const response = await fetch('/api/find-matches', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        oldUrls,
        newUrls,
        batchSize: batchSizeValue,
        delayMs: batchDelayValue
      }),
    });
    
    // Handle HTTP errors
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error || 'Failed to process URLs', { 
        cause: { solution: errorData.solution } 
      });
    }
    
    const data = await response.json();
    mappings = data.mappings;
    
    // Step 4: Generate explanations if enabled
    if (showExplanations.checked && mappings.length > 0) {
      updateProgress('Generating explanations...', 75);
      
      // Process explanations in batches to avoid rate limits
      const explanationBatchSize = 3; // Smaller batch size for explanations
      
      for (let i = 0; i < mappings.length; i += explanationBatchSize) {
        const batch = mappings.slice(i, i + explanationBatchSize);
        
        // Process batch with Promise.all for parallel requests
        const batchPromises = batch.map(async (mapping, index) => {
          try {
            const explResponse = await fetch('/api/explanations', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                oldUrl: mapping.oldUrl,
                newUrl: mapping.newUrl,
                confidence: mapping.confidence,
              }),
            });
            
            if (explResponse.ok) {
              const explData = await explResponse.json();
              mapping.explanation = explData.explanation;
            } else {
              mapping.explanation = 'Could not generate explanation.';
            }
          } catch (error) {
            console.error('Error generating explanation:', error);
            mapping.explanation = 'Error generating explanation.';
          }
        });
        
        // Wait for all explanations in this batch
        await Promise.all(batchPromises);
        
        // Add delay between batches
        if (i + explanationBatchSize < mappings.length) {
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
        
        // Update progress for explanations
        updateProgress('Generating explanations...', 75 + (i / mappings.length) * 20);
      }
    }
    
    // Step 5: Display results
    updateProgress('Completed successfully!', 100);
    displayResults(mappings);
    showAlert('URL mapping completed successfully!', 'success');
  } catch (error) {
    console.error('Error processing files:', error);
    
    // Extract solution from error cause if available
    const solution = error.cause?.solution || 
      'Try adjusting batch size and delay in advanced settings, or check your network connection.';
    
    showAlert(`Error: ${error.message}`, 'error', solution);
    progressContainer.style.display = 'none';
  } finally {
    isProcessing = false;
    updateProcessButton();
  }
}
